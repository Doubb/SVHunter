package SVCrafter;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class NodeConnector {
    List<ObsrNode> nodes = null;
    List<DangerousNode> dnodes = null;
    List<Integer> printedNode = null;

    String originText;
    String[] obsrs;

    Map<String, String> pidtoProto = new HashMap<String, String>();

    Boolean ext = true;

    public NodeConnector(List<ObsrNode> nodeList, String origin){
        nodes = nodeList;
        dnodes = new ArrayList<DangerousNode>();
        printedNode = new ArrayList<Integer>();

        originText = origin;
        obsrs = originText.split("\n");
    }

    public void loadMap(){
        File f = new File("./exploit/payload_crafting/MapFromPIDToProtocol.txt");

        try{
            BufferedReader br = new BufferedReader(new FileReader(f));
            String mapInfo;

            while ((mapInfo = br.readLine()) != null) {
                if(mapInfo.trim().length() < 3){
                    continue;
                }

                String keyInfo = mapInfo.split("->")[0].trim();
                String valueInfo = mapInfo.split("->")[1].trim();

                pidtoProto.put(keyInfo, valueInfo);
            }
        } catch (FileNotFoundException e){
            e.printStackTrace();
        } catch (IOException e){
            e.printStackTrace();
        }


    }

    public void doConnect(){
        loadMap();

        // Construct Dangerous nodes list for all ObsrNode
        for(int i = 0; i < nodes.size(); i++){
            DangerousNode dnode = new DangerousNode(nodes.get(i));

            dnodes.add(dnode);
        }

        // check if each 2 nodes can be connected
        for(int i = 0; i < dnodes.size(); i++){
            for(int j = 0; j < dnodes.size(); j++){
                // Ignore self-connections
                if(i == j)
                    continue;

                // If i is predecessor of j
                if(dnodes.get(i).content.isPredecessorOf(dnodes.get(j).content, false)){
                    if(dnodes.get(i).content.consequence.get(0).domain.domain_type.equals(dnodes.get(j).content.consequence.get(0).domain.domain_type)
                            && dnodes.get(i).content.consequence.get(0).domain.pid.getPathString().equals(dnodes.get(j).content.consequence.get(0).domain.pid.getPathString()))
                        continue;

                    ObsrNode ni = dnodes.get(i).content;
                    ObsrNode nj = dnodes.get(j).content;

                    if(nj.consequence.get(0).domain.isContained(ni.consequence.get(0).domain) || nj.preCondition.get(0).domain.pid.getPathString().length() == 9){
                        dnodes.get(i).addNextNode(dnodes.get(j));
                        dnodes.get(j).addPreNode(dnodes.get(i));
                    }
                }
            }
        }

        System.out.println("All nodes connected.\r\n");

        output();

        return;
    }

    public void output(){
        try{
            // Create dot file
            File dotFile = new File("results/output.dot");
            if(!dotFile.getParentFile().exists())
                dotFile.getParentFile().mkdirs();
            dotFile.createNewFile();

            for(ObsrNode nnode: nodes){
                if(nnode.preCondition.get(0).domain.domain_type.equals("proto_msg")){
                    writeCfg(nnode);
                }
            }
            File msgInfoFile = new File("results/");
            msgInfoFile.createNewFile();

            // Create FileWriter for each file
            FileWriter dotFileWriter = new FileWriter("results/output.dot");

            // Initial path List
            ArrayList<ObsrNode> path = new ArrayList<ObsrNode>();

            // Output the graph style to output.dot
            dotFileWriter.write("digraph g {\n" +
                    "  edge[];\n" +
                    "  node[shape=record];\n");
            dotFileWriter.write("  start_node [label=\"Malicious Device\"]\n");

            int cnt = 0;
            for(int i = 0; i < dnodes.size(); i++){
                String nodeDesc = String.format("  node%d [label=\"{<f0> %s|<f1> pid:%s\\nvar:var#%d}\" shape=Mrecord];\n",
                        cnt, dnodes.get(i).content.preCondition.get(0).domain.domain_type, dnodes.get(i).content.preCondition.get(0).domain.pid.getPathString().replaceAll("\\{|\\}", ""), cnt);

                cnt++;
                dotFileWriter.write(nodeDesc);
            }

            // Traverse the dangerous node list to find connections(for output.dot) and paths(for path.txt)
            for(int i = 0; i < dnodes.size(); i++){
                // node i is the first node of current path
                path.add(dnodes.get(i).content);

                // if node i does have next nodes && node i has not been printed
                if(dnodes.get(i).nextNode.size() > 0 && !printedNode.contains(i)){
                    // if ((ext is enabled && the stage of node i is toe stage) || ext is disabled)
                    if(!ext || dnodes.get(i).stage.equals("toe")) {
                        // mark node i as a printed node
                        printedNode.add(i);

                        // Traverse the next node list of node i
                        for (int j = 0; j < dnodes.get(i).nextNode.size(); j++) {
                            // Print connections from node i
                            dotFileWriter.write("  node" + i + ":f1->node" + dnodes.indexOf(dnodes.get(i).nextNode.get(j)) + ":f0;\r\n");

                            // Get next node for recursive call
                            DangerousNode nextNode = dnodes.get(i).nextNode.get(j);
                            // Add next node to path list
                            path.add(nextNode.content);

                            // Call output(x, x, x) to get all connections for node i
                            output(dnodes.get(i).nextNode.get(j), dotFileWriter, 1);

                            // Remove next node from current path
                            path.remove(nextNode.content);
                        }
                        //break;
                    }
                // if current node is a crash node
                } else if(dnodes.get(i).content.consequence.get(0).primitive.op_type == 3){
                    // mark node i as a printed node
                    printedNode.add(i);

                    dotFileWriter.write("  node" + i + ":f1->node" + i + ":f0;\r\n");
                }
                // Complete the traversing for node i. Remove it from current path
                path.remove(dnodes.get(i).content);
            }

            dotFileWriter.write("}");
            dotFileWriter.flush();
            dotFileWriter.close();
        } catch (IOException e){
            e.printStackTrace();
        }
    }

    public void output(DangerousNode dnode, FileWriter fw, int cnt){
        if(printedNode.contains(dnodes.indexOf(dnode)) || (ext && dnode.stage.equals("final"))){
            return;
        }
        else{
            try{
                printedNode.add(dnodes.indexOf(dnode));
                for(int j = 0; j < dnode.nextNode.size(); j++){
                    fw.write("  node" + dnodes.indexOf(dnode) + ":f1->node" + dnodes.indexOf(dnode.nextNode.get(j)) + ":f0;\r\n");
                    DangerousNode nextNode = dnode.nextNode.get(j);
                    if(!printedNode.contains(dnodes.indexOf(nextNode))) {
                        output(nextNode, fw, cnt + 1);
                    }
                }

                return;
            } catch(IOException e){
                e.printStackTrace();
            }

        }
    }

    public void writeCfg(ObsrNode nnode){
        String obsr = null;

        for(String s: obsrs){
            if(s.indexOf(nnode.consequence.get(0).primitive.var_name) != -1){
                obsr = s;
                break;
            }
        }

        String endpoint = obsr.substring(obsr.indexOf("[") + 1, obsr.indexOf("]"));
        Integer startIndex = endpoint.indexOf(":") + 1;
        Integer endIndex = endpoint.indexOf("at Line");
        String endMethod = endpoint.substring(startIndex, endIndex);
        endMethod = endMethod.trim();

        String protoInfo = pidtoProto.get(nnode.preCondition.get(0).domain.pid.getPathString());

        if (protoInfo == null)
            return;
        String proto = protoInfo.split("\\.")[0];
        String msg = protoInfo.split("\\.")[1];
        String field = protoInfo.split("\\.")[2];

        String leftValue = String.format("%s :: %s -> %s", proto, msg, field);

        String rightValue = "To do";

        try{
            File msgFile = new File("results/" + nnode.consequence.get(0).primitive.var_name + ".cfg");
            if(!msgFile.getParentFile().exists())
                msgFile.getParentFile().mkdirs();
            msgFile.createNewFile();

            FileWriter msgFileWriter = new FileWriter("results/" + nnode.consequence.get(0).primitive.var_name + ".cfg");
            msgFileWriter.write(String.format("%s = %s", leftValue, rightValue));
            msgFileWriter.flush();
            msgFileWriter.close();
        } catch (IOException e){
            e.printStackTrace();
        }

    }

}
